{"ast":null,"code":"// /client/src/services/CommunicationService.ts\n// Dedicated service for communication logging and interaction tracking\n\nimport BaseService from './baseServices';\nclass CommunicationService extends BaseService {\n  // ===== COMMUNICATION LOGGING =====\n\n  /**\n   * Log a new communication with a supporter\n   */\n  async logCommunication(supporterId, communicationData) {\n    return this.request(`/supporters/${supporterId}/communications`, {\n      method: 'POST',\n      body: JSON.stringify(communicationData)\n    });\n  }\n\n  /**\n   * Get communication history for a supporter\n   */\n  async getCommunicationHistory(supporterId, limit = 50) {\n    return this.request(`/supporters/${supporterId}/communications?limit=${limit}`);\n  }\n\n  /**\n   * Update an existing communication record\n   */\n  async updateCommunication(communicationId, updates) {\n    return this.request(`/communications/${communicationId}`, {\n      method: 'PUT',\n      body: JSON.stringify(updates)\n    });\n  }\n\n  /**\n   * Delete a communication record\n   */\n  async deleteCommunication(communicationId) {\n    return this.request(`/communications/${communicationId}`, {\n      method: 'DELETE'\n    });\n  }\n\n  // ===== FOLLOW-UP TASK MANAGEMENT =====\n\n  /**\n   * Get all follow-up tasks for a club\n   */\n  async getFollowUpTasks(clubId, overdue = false) {\n    return this.request(`/clubs/${clubId}/follow-up-tasks?overdue=${overdue}`);\n  }\n\n  /**\n   * Mark a follow-up task as completed\n   */\n  async completeFollowUpTask(communicationId, completionNotes) {\n    return this.request(`/communications/${communicationId}/complete-follow-up`, {\n      method: 'POST',\n      body: JSON.stringify({\n        completion_notes: completionNotes\n      })\n    });\n  }\n\n  /**\n   * Reschedule a follow-up task\n   */\n  async rescheduleFollowUp(communicationId, newDate, reason) {\n    return this.request(`/communications/${communicationId}/reschedule-follow-up`, {\n      method: 'POST',\n      body: JSON.stringify({\n        follow_up_date: newDate,\n        reschedule_reason: reason\n      })\n    });\n  }\n\n  // ===== COMMUNICATION ANALYTICS =====\n\n  /**\n   * Get communication summary and analytics for a club\n   */\n  async getCommunicationSummary(clubId, dateRange) {\n    const params = dateRange ? `?date_from=${dateRange.from}&date_to=${dateRange.to}` : '';\n    return this.request(`/clubs/${clubId}/communications/summary${params}`);\n  }\n\n  /**\n   * Get communication statistics by type\n   */\n  async getCommunicationStatsByType(clubId, timeframe = 'month') {\n    return this.request(`/clubs/${clubId}/communications/stats-by-type?timeframe=${timeframe}`);\n  }\n\n  /**\n   * Get communication outcome analysis\n   */\n  async getCommunicationOutcomes(clubId, supporterType) {\n    const params = supporterType ? `?supporter_type=${supporterType}` : '';\n    return this.request(`/clubs/${clubId}/communications/outcomes${params}`);\n  }\n\n  // ===== COMMUNICATION TEMPLATES =====\n\n  /**\n   * Get communication templates for quick logging\n   */\n  async getCommunicationTemplates(clubId, type) {\n    const params = type ? `?type=${type}` : '';\n    return this.request(`/clubs/${clubId}/communication-templates${params}`);\n  }\n\n  /**\n   * Create a new communication template\n   */\n  async createCommunicationTemplate(clubId, templateData) {\n    return this.request(`/clubs/${clubId}/communication-templates`, {\n      method: 'POST',\n      body: JSON.stringify(templateData)\n    });\n  }\n\n  // ===== BULK COMMUNICATION OPERATIONS =====\n\n  /**\n   * Log communications for multiple supporters (bulk)\n   */\n  async bulkLogCommunications(communications) {\n    return this.request('/communications/bulk', {\n      method: 'POST',\n      body: JSON.stringify({\n        communications\n      })\n    });\n  }\n\n  /**\n   * Export communication history\n   */\n  async exportCommunications(clubId, filters) {\n    const params = filters ? `?${new URLSearchParams(filters).toString()}` : '';\n    return this.request(`/clubs/${clubId}/communications/export${params}`);\n  }\n\n  // ===== HELPER METHODS =====\n\n  /**\n   * Validate communication data before submission\n   */\n  validateCommunicationData(data) {\n    var _data$notes;\n    const errors = [];\n    if (!data.type) {\n      errors.push('Communication type is required');\n    }\n    if (!data.direction) {\n      errors.push('Communication direction is required');\n    }\n    if (!((_data$notes = data.notes) !== null && _data$notes !== void 0 && _data$notes.trim())) {\n      errors.push('Communication notes are required');\n    }\n    if (data.follow_up_required && !data.follow_up_date) {\n      errors.push('Follow-up date is required when follow-up is marked as required');\n    }\n    if (data.follow_up_date) {\n      const followUpDate = new Date(data.follow_up_date);\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      if (followUpDate < today) {\n        errors.push('Follow-up date cannot be in the past');\n      }\n    }\n    if (data.duration_minutes && data.duration_minutes < 0) {\n      errors.push('Duration cannot be negative');\n    }\n    return errors;\n  }\n\n  /**\n   * Format communication for display\n   */\n  formatCommunicationForDisplay(communication) {\n    return {\n      ...communication,\n      formatted_date: this.formatDate(communication.created_at),\n      formatted_duration: this.formatDuration(communication.duration_minutes),\n      type_label: this.getCommunicationTypeLabel(communication.type),\n      outcome_badge: this.getOutcomeBadge(communication.outcome),\n      is_overdue: this.isFollowUpOverdue(communication.follow_up_date)\n    };\n  }\n\n  /**\n   * Get communication statistics for a supporter\n   */\n  async getSupporterCommunicationStats(supporterId) {\n    var _communications$;\n    const history = await this.getCommunicationHistory(supporterId, 100);\n    const communications = history.communications || [];\n    const stats = {\n      total_communications: communications.length,\n      last_contact: ((_communications$ = communications[0]) === null || _communications$ === void 0 ? void 0 : _communications$.created_at) || null,\n      communication_types: this.groupBy(communications, 'type'),\n      outcomes: this.groupBy(communications, 'outcome'),\n      pending_follow_ups: communications.filter(c => c.follow_up_required && !c.follow_up_completed).length,\n      avg_response_time: this.calculateAverageResponseTime(communications)\n    };\n    return stats;\n  }\n\n  // ===== PRIVATE HELPER METHODS =====\n\n  formatDate(dateString) {\n    return new Date(dateString).toLocaleDateString('en-GB', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  }\n  formatDuration(minutes) {\n    if (!minutes) return '';\n    if (minutes < 60) {\n      return `${minutes}m`;\n    }\n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;\n  }\n  getCommunicationTypeLabel(type) {\n    const labels = {\n      call: 'Phone Call',\n      email: 'Email',\n      meeting: 'Meeting',\n      letter: 'Letter',\n      sms: 'SMS',\n      social_media: 'Social Media',\n      event_interaction: 'Event Interaction',\n      other: 'Other'\n    };\n    return labels[type] || type;\n  }\n  getOutcomeBadge(outcome) {\n    const badges = {\n      positive: {\n        color: 'green',\n        label: 'Positive'\n      },\n      neutral: {\n        color: 'gray',\n        label: 'Neutral'\n      },\n      negative: {\n        color: 'red',\n        label: 'Negative'\n      },\n      no_response: {\n        color: 'yellow',\n        label: 'No Response'\n      },\n      callback_requested: {\n        color: 'blue',\n        label: 'Callback Requested'\n      }\n    };\n    return badges[outcome] || badges.neutral;\n  }\n  isFollowUpOverdue(followUpDate) {\n    if (!followUpDate) return false;\n    return new Date(followUpDate) < new Date();\n  }\n  groupBy(array, key) {\n    return array.reduce((acc, item) => {\n      const group = item[key] || 'unknown';\n      acc[group] = (acc[group] || 0) + 1;\n      return acc;\n    }, {});\n  }\n  calculateAverageResponseTime(communications) {\n    // Simple calculation - you can enhance this based on your needs\n    const responseTimes = communications.filter(c => c.direction === 'outbound').map(c => {\n      // Calculate time between communications\n      // This is a simplified version\n      return 1; // placeholder\n    });\n    return responseTimes.length > 0 ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 0;\n  }\n}\nexport default new CommunicationService();","map":{"version":3,"names":["BaseService","CommunicationService","logCommunication","supporterId","communicationData","request","method","body","JSON","stringify","getCommunicationHistory","limit","updateCommunication","communicationId","updates","deleteCommunication","getFollowUpTasks","clubId","overdue","completeFollowUpTask","completionNotes","completion_notes","rescheduleFollowUp","newDate","reason","follow_up_date","reschedule_reason","getCommunicationSummary","dateRange","params","from","to","getCommunicationStatsByType","timeframe","getCommunicationOutcomes","supporterType","getCommunicationTemplates","type","createCommunicationTemplate","templateData","bulkLogCommunications","communications","exportCommunications","filters","URLSearchParams","toString","validateCommunicationData","data","_data$notes","errors","push","direction","notes","trim","follow_up_required","followUpDate","Date","today","setHours","duration_minutes","formatCommunicationForDisplay","communication","formatted_date","formatDate","created_at","formatted_duration","formatDuration","type_label","getCommunicationTypeLabel","outcome_badge","getOutcomeBadge","outcome","is_overdue","isFollowUpOverdue","getSupporterCommunicationStats","_communications$","history","stats","total_communications","length","last_contact","communication_types","groupBy","outcomes","pending_follow_ups","filter","c","follow_up_completed","avg_response_time","calculateAverageResponseTime","dateString","toLocaleDateString","year","month","day","hour","minute","minutes","hours","Math","floor","remainingMinutes","labels","call","email","meeting","letter","sms","social_media","event_interaction","other","badges","positive","color","label","neutral","negative","no_response","callback_requested","array","key","reduce","acc","item","group","responseTimes","map","a","b"],"sources":["/home/paulag/fundraisely-club/client/src/services/communicationService.ts"],"sourcesContent":["// /client/src/services/CommunicationService.ts\n// Dedicated service for communication logging and interaction tracking\n\nimport BaseService from './baseServices';\n\nexport interface CreateCommunicationData {\n  // Required fields\n  type: 'call' | 'email' | 'meeting' | 'letter' | 'sms' | 'social_media' | 'event_interaction' | 'other';\n  direction: 'inbound' | 'outbound';\n  notes: string;\n  \n  // Optional details\n  subject?: string;\n  outcome?: 'positive' | 'neutral' | 'negative' | 'no_response' | 'callback_requested';\n  \n  // Follow-up management\n  follow_up_required?: boolean;\n  follow_up_date?: string;\n  follow_up_notes?: string;\n  \n  // Context linking\n  event_id?: string;\n  campaign_id?: string;\n  communication_channel?: string; // \"phone\", \"email\", \"zoom\", \"in_person\"\n  \n  // Additional metadata\n  duration_minutes?: number;\n  attachment_urls?: string[];\n  tags?: string[];\n}\n\nexport interface CommunicationFilters {\n  type?: string;\n  direction?: 'inbound' | 'outbound';\n  outcome?: string;\n  follow_up_required?: boolean;\n  date_from?: string;\n  date_to?: string;\n  limit?: number;\n}\n\nexport interface CommunicationSummary {\n  total_communications: number;\n  recent_communications: number;\n  pending_follow_ups: number;\n  communication_breakdown: Array<{ type: string; count: number }>;\n  outcome_breakdown: Array<{ outcome: string; count: number }>;\n  avg_response_time: number;\n}\n\nclass CommunicationService extends BaseService {\n  // ===== COMMUNICATION LOGGING =====\n\n  /**\n   * Log a new communication with a supporter\n   */\n  async logCommunication(supporterId: string, communicationData: CreateCommunicationData) {\n    return this.request<{ \n      message: string; \n      communication: any;\n    }>(`/supporters/${supporterId}/communications`, {\n      method: 'POST',\n      body: JSON.stringify(communicationData),\n    });\n  }\n\n  /**\n   * Get communication history for a supporter\n   */\n  async getCommunicationHistory(supporterId: string, limit: number = 50) {\n    return this.request<{ \n      communications: any[]; \n      supporter_id: string; \n      total_retrieved: number;\n    }>(`/supporters/${supporterId}/communications?limit=${limit}`);\n  }\n\n  /**\n   * Update an existing communication record\n   */\n  async updateCommunication(communicationId: string, updates: Partial<CreateCommunicationData>) {\n    return this.request<{ \n      message: string; \n      communication: any;\n    }>(`/communications/${communicationId}`, {\n      method: 'PUT',\n      body: JSON.stringify(updates),\n    });\n  }\n\n  /**\n   * Delete a communication record\n   */\n  async deleteCommunication(communicationId: string) {\n    return this.request<{ message: string }>(`/communications/${communicationId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // ===== FOLLOW-UP TASK MANAGEMENT =====\n\n  /**\n   * Get all follow-up tasks for a club\n   */\n  async getFollowUpTasks(clubId: string, overdue: boolean = false) {\n    return this.request<{ \n      follow_up_tasks: any[]; \n      is_overdue_filter: boolean; \n      total_tasks: number;\n    }>(`/clubs/${clubId}/follow-up-tasks?overdue=${overdue}`);\n  }\n\n  /**\n   * Mark a follow-up task as completed\n   */\n  async completeFollowUpTask(communicationId: string, completionNotes?: string) {\n    return this.request<{ \n      message: string; \n      communication: any;\n    }>(`/communications/${communicationId}/complete-follow-up`, {\n      method: 'POST',\n      body: JSON.stringify({ completion_notes: completionNotes }),\n    });\n  }\n\n  /**\n   * Reschedule a follow-up task\n   */\n  async rescheduleFollowUp(communicationId: string, newDate: string, reason?: string) {\n    return this.request<{ \n      message: string; \n      communication: any;\n    }>(`/communications/${communicationId}/reschedule-follow-up`, {\n      method: 'POST',\n      body: JSON.stringify({ \n        follow_up_date: newDate, \n        reschedule_reason: reason \n      }),\n    });\n  }\n\n  // ===== COMMUNICATION ANALYTICS =====\n\n  /**\n   * Get communication summary and analytics for a club\n   */\n  async getCommunicationSummary(clubId: string, dateRange?: { from: string; to: string }) {\n    const params = dateRange \n      ? `?date_from=${dateRange.from}&date_to=${dateRange.to}` \n      : '';\n    \n    return this.request<{ \n      communication_summary: CommunicationSummary; \n      date_range: any; \n      generated_at: string;\n    }>(`/clubs/${clubId}/communications/summary${params}`);\n  }\n\n  /**\n   * Get communication statistics by type\n   */\n  async getCommunicationStatsByType(clubId: string, timeframe: 'week' | 'month' | 'quarter' | 'year' = 'month') {\n    return this.request<{ \n      statistics: Array<{ type: string; count: number; avg_duration: number }>; \n      timeframe: string;\n    }>(`/clubs/${clubId}/communications/stats-by-type?timeframe=${timeframe}`);\n  }\n\n  /**\n   * Get communication outcome analysis\n   */\n  async getCommunicationOutcomes(clubId: string, supporterType?: 'volunteer' | 'donor' | 'sponsor') {\n    const params = supporterType ? `?supporter_type=${supporterType}` : '';\n    return this.request<{ \n      outcome_analysis: Array<{ outcome: string; count: number; percentage: number }>; \n      supporter_type: string | null;\n    }>(`/clubs/${clubId}/communications/outcomes${params}`);\n  }\n\n  // ===== COMMUNICATION TEMPLATES =====\n\n  /**\n   * Get communication templates for quick logging\n   */\n  async getCommunicationTemplates(clubId: string, type?: string) {\n    const params = type ? `?type=${type}` : '';\n    return this.request<{ \n      templates: Array<{ \n        id: string; \n        name: string; \n        type: string; \n        subject_template: string; \n        notes_template: string; \n      }>; \n    }>(`/clubs/${clubId}/communication-templates${params}`);\n  }\n\n  /**\n   * Create a new communication template\n   */\n  async createCommunicationTemplate(clubId: string, templateData: {\n    name: string;\n    type: string;\n    subject_template: string;\n    notes_template: string;\n    tags?: string[];\n  }) {\n    return this.request<{ \n      message: string; \n      template: any;\n    }>(`/clubs/${clubId}/communication-templates`, {\n      method: 'POST',\n      body: JSON.stringify(templateData),\n    });\n  }\n\n  // ===== BULK COMMUNICATION OPERATIONS =====\n\n  /**\n   * Log communications for multiple supporters (bulk)\n   */\n  async bulkLogCommunications(communications: Array<{\n    supporter_id: string;\n    communication_data: CreateCommunicationData;\n  }>) {\n    return this.request<{ \n      message: string; \n      result: {\n        successful: any[];\n        errors: any[];\n        total_processed: number;\n      };\n    }>('/communications/bulk', {\n      method: 'POST',\n      body: JSON.stringify({ communications }),\n    });\n  }\n\n  /**\n   * Export communication history\n   */\n  async exportCommunications(clubId: string, filters?: CommunicationFilters & { format?: 'csv' }) {\n    const params = filters ? `?${new URLSearchParams(filters as any).toString()}` : '';\n    return this.request<{ \n      export_data: any[]; \n      filename: string; \n      total_records: number; \n      filters_applied: any;\n    }>(`/clubs/${clubId}/communications/export${params}`);\n  }\n\n  // ===== HELPER METHODS =====\n\n  /**\n   * Validate communication data before submission\n   */\n  validateCommunicationData(data: CreateCommunicationData): string[] {\n    const errors: string[] = [];\n\n    if (!data.type) {\n      errors.push('Communication type is required');\n    }\n\n    if (!data.direction) {\n      errors.push('Communication direction is required');\n    }\n\n    if (!data.notes?.trim()) {\n      errors.push('Communication notes are required');\n    }\n\n    if (data.follow_up_required && !data.follow_up_date) {\n      errors.push('Follow-up date is required when follow-up is marked as required');\n    }\n\n    if (data.follow_up_date) {\n      const followUpDate = new Date(data.follow_up_date);\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      if (followUpDate < today) {\n        errors.push('Follow-up date cannot be in the past');\n      }\n    }\n\n    if (data.duration_minutes && data.duration_minutes < 0) {\n      errors.push('Duration cannot be negative');\n    }\n\n    return errors;\n  }\n\n  /**\n   * Format communication for display\n   */\n  formatCommunicationForDisplay(communication: any) {\n    return {\n      ...communication,\n      formatted_date: this.formatDate(communication.created_at),\n      formatted_duration: this.formatDuration(communication.duration_minutes),\n      type_label: this.getCommunicationTypeLabel(communication.type),\n      outcome_badge: this.getOutcomeBadge(communication.outcome),\n      is_overdue: this.isFollowUpOverdue(communication.follow_up_date),\n    };\n  }\n\n  /**\n   * Get communication statistics for a supporter\n   */\n  async getSupporterCommunicationStats(supporterId: string) {\n    const history = await this.getCommunicationHistory(supporterId, 100);\n    \n    const communications = history.communications || [];\n    \n    const stats = {\n      total_communications: communications.length,\n      last_contact: communications[0]?.created_at || null,\n      communication_types: this.groupBy(communications, 'type'),\n      outcomes: this.groupBy(communications, 'outcome'),\n      pending_follow_ups: communications.filter((c: any) => \n        c.follow_up_required && !c.follow_up_completed\n      ).length,\n      avg_response_time: this.calculateAverageResponseTime(communications),\n    };\n\n    return stats;\n  }\n\n  // ===== PRIVATE HELPER METHODS =====\n\n  protected formatDate(dateString: string): string {\n    return new Date(dateString).toLocaleDateString('en-GB', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  }\n\n  protected formatDuration(minutes?: number): string {\n    if (!minutes) return '';\n    \n    if (minutes < 60) {\n      return `${minutes}m`;\n    }\n    \n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    \n    return remainingMinutes > 0 \n      ? `${hours}h ${remainingMinutes}m`\n      : `${hours}h`;\n  }\n\n  protected getCommunicationTypeLabel(type: string): string {\n    const labels: Record<string, string> = {\n      call: 'Phone Call',\n      email: 'Email',\n      meeting: 'Meeting',\n      letter: 'Letter',\n      sms: 'SMS',\n      social_media: 'Social Media',\n      event_interaction: 'Event Interaction',\n      other: 'Other'\n    };\n    \n    return labels[type] || type;\n  }\n\n  protected getOutcomeBadge(outcome?: string) {\n    const badges = {\n      positive: { color: 'green', label: 'Positive' },\n      neutral: { color: 'gray', label: 'Neutral' },\n      negative: { color: 'red', label: 'Negative' },\n      no_response: { color: 'yellow', label: 'No Response' },\n      callback_requested: { color: 'blue', label: 'Callback Requested' }\n    };\n    \n    return badges[outcome as keyof typeof badges] || badges.neutral;\n  }\n\n  protected isFollowUpOverdue(followUpDate?: string): boolean {\n    if (!followUpDate) return false;\n    return new Date(followUpDate) < new Date();\n  }\n\n  protected groupBy(array: any[], key: string): Record<string, number> {\n    return array.reduce((acc, item) => {\n      const group = item[key] || 'unknown';\n      acc[group] = (acc[group] || 0) + 1;\n      return acc;\n    }, {});\n  }\n\n  protected calculateAverageResponseTime(communications: any[]): number {\n    // Simple calculation - you can enhance this based on your needs\n    const responseTimes = communications\n      .filter((c: any) => c.direction === 'outbound')\n      .map((c: any) => {\n        // Calculate time between communications\n        // This is a simplified version\n        return 1; // placeholder\n      });\n    \n    return responseTimes.length > 0 \n      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length \n      : 0;\n  }\n}\n\nexport default new CommunicationService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}